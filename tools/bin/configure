#!/usr/bin/python3

import sys
import os
from plumbum import local

rm = local['rm']['-f']
ln = local['ln']['-s']
cp = local['cp']
mkdir = local['mkdir']

# Check that the config file exists.
if not os.path.isfile('configuration.rvex'):
    print('Error: no configuration.rvex was found in the current directory.')
    sys.exit(1)

# Parse the configuration file.
errors = False
keys = set(['CONFIG', 'CONTEXTS', 'ICACHE', 'DCACHE', 'STOPBIT'])

with open('configuration.rvex', 'r') as f:
    lines = f.readlines()
lines = [(n+1, l.split('#')[0].strip()) for n, l in enumerate(lines)]
lines = [(n, l) for n, l in lines if l]
cores = []
for n, l in lines:
    if l == '[core]':
        cores.append({'linenr': n})
        continue
    elif not cores:
        print('Error: unknown configuration token before the first [core] on line %d.' % n)
        errors = True
        continue
    l = [x.strip() for x in l.split('=', 1)]
    if len(l) != 2:
        print('Error: syntax error on line %d.' % n)
        errors = True
        continue
    if l[0] not in keys:
        print('Error: unknown configuration key on line %d.' % n)
        errors = True
        continue
    cores[-1][l[0]] = (n, l[1])
for c in cores:
    for k in keys:
        if k not in c:
            print('Error: core defined on line %d is missing configuration key %s.' % (c['linenr'], k))
            errors = True
    linenr = c['linenr']
    del c['linenr']
    nc = {}
    for k in c:
        n, v = c[k]
        if k.endswith('CACHE'):
            mult = 1
            if v.endswith('k'):
                mult = 1024
                v = v[:-1].strip()
            try:
                v = int(v) * mult
            except ValueError:
                print('Error: parse error on line %d.' % n)
                errors = True
                continue
            if (v & (v - 1)) != 0:
                print('Error: cache size is not a power of 2 on line %d.' % n)
                errors = True
                continue
            v = int.bit_length(v) - 1
            nc[k[0].lower() + 'cacheLog2'] = v
        elif k == 'CONFIG':
            v = v[::-1]
            vc = v.replace(':', '')
            v = v.split(':')
            
            # Check multiplier config.
            try:
                nv = int(vc, 16)
                if nv & 0xEEEEEEEE:
                    raise ValueError()
            except ValueError:
                print('Error: parse error on line %d.' % n)
                errors = True
                continue
            if nv == 0:
                print('Error: there should be at least one multiplier in the core on line %d.' % n)
                errors = True
                continue
            
            # Check issue width.
            if len(vc) not in [2, 4, 8]:
                print('Error: issue width must be 2, 4, or 8 on line %d.' % n)
                errors = True
                continue
            
            # Check reconfiguration config.
            if len(v) not in [1, 2, 4]:
                print('Error: all groups must have the same issue width on line %d.' % n)
                errors = True
                continue
            if len(v[0]) not in [2, 4, 8]:
                print('Error: the issue width of a group must be 2, 4, or 8 on line %d.' % n)
                errors = True
                break
            if '1' not in v[0]:
                print('Error: each group should have at least one multiplier on line %d.' % n)
                errors = True
                break
            for vg in v:
                if vg != v[0]:
                    print('Error: all groups must have the same issue width and multiplier config on line %d.' % n)
                    errors = True
                    break
            
            # Configure the hardware.
            nc['numLaneGroups'] = len(v)
            nc['numLaneGroupsLog2'] = [1, 2, 4].index(len(v))
            nc['numLanes'] = len(vc)
            nc['numLanesLog2'] = [1, 2, 4, 8].index(len(vc))
            nc['numLanesPerGroup'] = len(v[0])
            nc['memLaneRevIndex'] = len(v[0]) - 1
            nc['multipliers'] = vc
            
            # Configure the compiler.
            if len(v) > 1:
                nc['compiler-genbin'] = True
                nc['compiler-width'] = 8
                nc['compiler-borrow'] = '1.0.3.2.5.4.7.6'
                nc['compiler-config'] = v[0] * (8 // len(v[0]))
            else:
                nc['compiler-genbin'] = False
                nc['compiler-width'] = len(vc)
                nc['compiler-borrow'] = {2: '1.0', 4: '1.0.3.2', 8: '1.0.3.2.5.4.7.6'}[len(vc)]
                nc['compiler-config'] = vc
            nc['compiler-multCount'] = nc['compiler-config'].count('1')

        elif k == 'STOPBIT':
            if v not in ['2', '4', '8']:
                print('Error: stop bit config must be 2, 4, or 8 on line %d.' % n)
                errors = True
                continue
            nc['bundleAlignLog2'] = int.bit_length(int(v)) - 1
            nc['compiler-bundleAlign'] = int(v)
            
        elif k == 'CONTEXTS':
            if v not in ['1', '2', '4']:
                print('Error: the number of contexts must be 1, 2, or 4 on line %d.' % n)
                errors = True
                continue
            nc['numContexts'] = int(v)
            nc['numContextsLog2'] = ['1', '2', '4'].index(v)
        else:
            raise RuntimeError('No parser for key %s', k)
    if 'icacheLog2' in nc and 'numLanesLog2' in nc:
        nc['icacheLog2'] -= nc['numLaneGroupsLog2'] + nc['numLanesLog2'] + 2
        if nc['icacheLog2'] < 1:
            print('Error: instruction cache too small on line %d.' % c['ICACHE'][0])
            errors = True
            continue
    if 'dcacheLog2' in nc:
        nc['dcacheLog2'] -= nc['numLaneGroupsLog2'] + 2
        if nc['dcacheLog2'] < 1:
            print('Error: data cache too small on line %d.' % c['DCACHE'][0])
            errors = True
            continue
    if 'bundleAlignLog2' in nc and 'numLanesLog2' in nc:
        if nc['bundleAlignLog2'] > nc['numLanesLog2']:
            nc['bundleAlignLog2'] = nc['numLanesLog2']
            nc['compiler-bundleAlign'] = 2**nc['numLanesLog2']
            print('Warning: stop bit config is greater than issue width for core on line %d.' % linenr)
    
    if not errors:
        # Figure out the lane configuration for the compiler:
        #  - Bit 0: ALU
        laneconfig = int('1' * nc['compiler-width'], 16)
        #  - Bit 1: Multiplier
        laneconfig |= int(nc['compiler-config'], 16) << 1
        #  - Bit 2: Memory
        mem = ['0'] * nc['numLanesPerGroup']
        mem[-(nc['memLaneRevIndex'] + 1)] = '4'
        mem = ''.join(mem)
        mem *= nc['compiler-width'] // nc['numLanesPerGroup']
        laneconfig |= int(mem, 16)
        #  - Bit 3: Branch
        br = ['0'] * nc['compiler-width']
        for i in range(0, nc['compiler-width'], nc['compiler-bundleAlign']):
            br[i + nc['compiler-bundleAlign'] - 1] = '8'
        for i in range(0, nc['compiler-width'], nc['numLanesPerGroup']):
            br[i + nc['numLanesPerGroup'] - 1] = '8'
        laneconfig |= int(''.join(br), 16)
        # And store it as a string.
        nc['compiler-config'] = '%0*X' % (nc['compiler-width'], laneconfig)
    
    c.clear()
    c.update(nc)
if errors:
    sys.exit(1)

# Determine which benchmarks this group needs to run.
benchmarks_file = '/home/user/workspace/assignment2/benchmarks'
if not os.path.isfile(benchmarks_file):
    print('Warning: benchmarks file does not exist. Cannot properly initialize src directory.')
    print('  (/home/user/workspace/assignment2/benchmarks)')
    benchmarks = []
else:
    with open(benchmarks_file, 'r') as f:
        benchmarks = [x.strip() for x in f.readlines()[2:]]

# Query overriding things.
if os.path.isdir('data'):
    print('Warning! Reconfiguring will delete all files in the data and result directories!')
    print('That includes any synthesis data/bitstreams that you may have built here. Are')
    print('you sure you want to delete these things? [y/n]')
    if input() != 'y':
        sys.exit(1)

# Clean up, then rebuild data directory structure.
rm('-r', 'data')
rm('-r', 'results')
mkdir('-p', 'data/compile')
mkdir('-p', 'data/fpga')
mkdir('-p', 'results')

# If the source directory does not exist yet, construct it.
if not os.path.isdir('src'):
    mkdir('-p', 'src')
    
    # Copy the benchmark sources into the src tree.
    benchmarks_old = benchmarks
    benchmarks = []
    for b in benchmarks_old:
        filename = '/home/user/workspace/assignment2/powerstone/%s.c' % b
        if not os.path.isfile(filename):
            print('Warning: cannot find source for benchmark "%s". Removing benchmark from list.', b)
            print('  (%s)', filename)
        else:
            cp('-p', filename, 'src')
            benchmarks.append(b)
    
    


sys.exit(0)
###################################################################################################
###################################################################################################
###################################################################################################
###################################################################################################


# Generate the compile directory and the machine configuration files.
mm_template = """
RES: IssueWidth     {issuewidth}
RES: MemLoad        1
RES: MemStore       1
RES: MemPft         0
# ***Clusters***    1
RES: IssueWidth.0   {issuewidth}
RES: Alu.0          {issuewidth}
RES: Mpy.0          {multipliers}
RES: Memory.0       1
RES: CopySrc.0      1
RES: CopyDst.0      1
REG: $r0            63
REG: $b0            8
DEL: AluR.0         0
DEL: Alu.0          0
DEL: CmpBr.0        0
DEL: CmpGr.0        0
DEL: Select.0       0
DEL: Multiply.0     1
DEL: Load.0         1
DEL: LoadLr.0       1
DEL: Store.0        0
DEL: Pft.0          0
DEL: CpGrBr.0       0
DEL: CpBrGr.0       0
DEL: CpGrLr.0       0
DEL: CpLrGr.0       0
DEL: Spill.0        0
DEL: Restore.0      1
DEL: RestoreLr.0    1
CFG: Quit           0
CFG: Warn           0
CFG: Debug          0
"""
for i, c in enumerate(cores):
    mkdir('-p', 'compile/core%d' % i)
    with open('compile/core%d/config.mm' % i, 'w') as f:
        f.write(mm_template.format(
            issuewidth = c['compiler-width'],
            multipliers = c['compiler-multCount']
        ))

# Generate the main C files and linker scripts.
linkerscript = """
OUTPUT_FORMAT("elf32-rvex")
OUTPUT_ARCH(rvex)
ENTRY(_start)
MEMORY
{
  ram : ORIGIN = 0x%08X, LENGTH = 32M
}
SECTIONS
{
  .text :
  {
    __TEXT_START = .;
    *(.init)
    *(.text)
    __TEXT_END = .;
  } > ram
  .data :
  {
    __DATA_START = .;
    *(.rodata*)
    *(.data_4) *(.data_2) *(.data_1) *(.data) *(.data.*) *(.gnu.linkonce.d.*)
    __DATA_END = .;
    . = ALIGN(16);
  } > ram
  .bss (NOLOAD) :
  {
    __BSS_START = .;
    *(.bss_4) *(.bss_2) *(.bss_1) *(.bss) *(COMMON) *(.bss.*) *(.gnu.linkonce.b.*)
    __BSS_END = .;
  } > ram
  .stack (NOLOAD) :
  {
    . = ALIGN(4);
    . += 0x6000;
    __STACK_START = .;
  } > ram
  .heap (NOLOAD) :
  {
    . = ALIGN(4);
    end = .;
    _end = .;
    __HEAP_START = .;
    . += 0x200000; 
    __HEAP_MAX = .;
  } > ram
  .comment        0 : { *(.comment) }
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
}
__DATA_IMAGE_START = LOADADDR(.data);
"""
for i, c in enumerate(cores):
    with open('compile/core%d/main.c' % i, 'w') as f:
        f.write('#include "rvex.h"\n')
        f.write('#include "record.h"\n')
        f.write('void %s_main(void);\n')
        f.write('volatile char *record_ptr = (volatile char*)0x%08X;\n' % (0x1F000000 + 0x00100000*i))
        f.write('int main(void) {\n')
        f.write('    log_perfcount("*** After init ***");\n')
        for b in c['benchmarks']:
            f.write('    %s_main();\n' % b)
            f.write('    log_perfcount("*** After %s ***");\n' % b)
        f.write('    return 0;\n')
        f.write('}\n')
    with open('compile/core%d/config.x' % i, 'w') as f:
        f.write(linkerscript % (i * 32*1024*1024))
    with open('compile/core%d/Makefile' % i, 'w') as f:
        f.write('\n')
        f.write('TARGETS      = _start main record common bcopy floatlib %s\n' % ' '.join([b + '-sub' for b in c['benchmarks']]))
        f.write('ISSUE_WIDTH  = %s\n' % c['compilerissuewidth'])
        f.write('BORROW       = %s\n' % c['compilerborrow'])
        f.write('LANECONFIG   = %s\n' % c['compilerlaneconfig'])
        f.write('BUNDLE_ALIGN = %s\n' % c['compilerbundlealign'])
        f.write('CFLAGS       = -O3\n')
        f.write('\n')
        f.write('include /home/user/workspace/assignment2/utils/compile-core.makefile\n')
        f.write('\n')

ln('/home/user/workspace/assignment2/utils/compile.makefile', 'compile/Makefile')

# Generate the grlib config.vhd file.
config_vhd_head = """
library techmap;
use techmap.gencomp.all;

library ieee;
use ieee.std_logic_1164.all;

library rvex;
use rvex.common_pkg.all;
use rvex.core_pkg.all;
use rvex.cache_pkg.all;
use rvex.rvsys_grlib_pkg.all;

package config is
-- Technology and synthesis options
  constant CFG_FABTECH : integer := virtex6;
  constant CFG_MEMTECH : integer := virtex6;
  constant CFG_PADTECH : integer := virtex6;
  constant CFG_NOASYNC : integer := 0;
  constant CFG_SCAN : integer := 0;
-- LEON3 processor core
  --constant CFG_DISAS : integer := 0 + 0;
  --constant CFG_PCLOW : integer := 2;
-- r-VEX processor core
  constant CFG_NRVEX : integer := {num_cores};
  constant CFG_RVEX_CFG : rvex_grlib_generic_config_array(0 to CFG_NRVEX-1) := (
"""
config_vhd_core = """    
    -- Core {index} configuration
    {index} => rvex_grlib_cfg(
      core => rvex_cfg(
        numLanesLog2          => {numLanesLog2},
        numLaneGroupsLog2     => 0,
        numContextsLog2       => 0,
        bundleAlignLog2       => {bundleAlignLog2},
        multiplierLanes       => 2#{multiplierLanes}#,
        memLaneRevIndex       => {memLaneRevIndex},
        numBreakpoints        => 0,
        forwarding            => 1,
        limmhFromPreviousPair => 0,
        resetVectors          => (others => X"{reset:08X}"),
        traceEnable           => 0,
        perfCountSize         => 4,
        cachePerfCountEnable  => 1
      ), core_valid => true,
    
      -- Cache configuration
      cache => cache_cfg(
        instrCacheLinesLog2   => {instrCacheLinesLog2},
        dataCacheLinesLog2    => {dataCacheLinesLog2}
      ), cache_valid => true)"""
config_vhd_foot = """
  
  );
-- Total number of processors
  constant CFG_NLG : integer := rvex_grlib_num_lane_groups(CFG_RVEX_CFG);
  constant CFG_NCTXT : integer := rvex_grlib_num_contexts(CFG_RVEX_CFG);
-- AMBA settings
  constant CFG_FPNPEN : integer := 0;
  constant CFG_AHBIO : integer := 16#FFF#;
  constant CFG_APBADDR : integer := 16#800#;
  constant CFG_AHB_MON : integer := 0;
  constant CFG_AHB_MONERR : integer := 0;
  constant CFG_AHB_MONWAR : integer := 0;
  constant CFG_AHB_DTRACE : integer := 0;
-- Xilinx MIG DDR2 controller
  constant CFG_MIG_DDR2 : integer := 1;
  --constant CFG_MIG_CLK4 : integer := 30; -- 40 MHz     (5.0ns sync with 200MHz DDR)
  --constant CFG_MIG_CLK4 : integer := 32; -- 37.5 MHz   (1.6ns sync with 200MHz DDR)
  --constant CFG_MIG_CLK4 : integer := 33; -- 36.36 MHz  (2.5ns sync with 200MHz DDR)
  --constant CFG_MIG_CLK4 : integer := 36; -- 33.33 MHz  (5.0ns sync with 200MHz DDR)
  --constant CFG_MIG_CLK4 : integer := 40; -- 30 MHz     (1.6ns sync with 200MHz DDR)
    constant CFG_MIG_CLK4 : integer := 60; -- 20 MHz     (5.0ns sync with 200MHz DDR)

end;
"""
with open('fpga/config.vhd', 'w') as f:
    f.write(config_vhd_head.format(num_cores=len(cores)))
    cs = []
    for i, c in enumerate(cores):
        cs.append(config_vhd_core.format(
            index               = i,
            numLanesLog2        = c['numlaneslog2'],
            bundleAlignLog2     = c['bundlealignlog2'],
            multiplierLanes     = c['multipliers'],
            memLaneRevIndex     = c['memlanerevindex'],
            reset               = i * 32*1024*1024,
            instrCacheLinesLog2 = c['icachelog2'],
            dataCacheLinesLog2  = c['dcachelog2']
        ))
    f.write(',\n'.join(cs))
    f.write(config_vhd_foot)
ln('/home/user/workspace/assignment2/utils/fpga.makefile', 'fpga/Makefile')

# Generate the modelsim .do script.
with open('fpga/phy.do', 'w') as f:
    for i, c in enumerate(cores):
        f.write('add wave -label "Core {0}" -expand sim:/testbench/d3/rvsys_gen({0})/rvsys_inst/rvex_block/rvex_inst/rv2sim\n'.format(i))



