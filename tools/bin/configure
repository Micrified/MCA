#!/usr/bin/python3

import sys
import os
from plumbum import local

rm = local['rm']['-f']
ln = local['ln']['-s']
cp = local['cp']
mkdir = local['mkdir']

###############################################################################
# Parse the platform configuration file.                                      #
###############################################################################

# Check that the config file exists.
if not os.path.isfile('configuration.rvex'):
    print('Error: no configuration.rvex was found in the current directory.')
    sys.exit(1)

# Parse the configuration file.
errors = False
keys = set(['CONFIG', 'ICACHE', 'DCACHE', 'STOPBIT'])

with open('configuration.rvex', 'r') as f:
    lines = f.readlines()
lines = [(n+1, l.split('#')[0].strip()) for n, l in enumerate(lines)]
lines = [(n, l) for n, l in lines if l]
cores = []

# Instruction/data memory regions. Length is the amount allocated per core.
mem_start  = 0x00000000
mem_length = 0x02000000
mem_end    = 0x1F000000

# Log memory regions. Length is the amount allocated per core.
log_start  = 0x1F000000
log_length = 0x00100000
log_end    = 0x20000000

for n, l in lines:
    if l == '[core]':
        cores.append({'linenr': n})
        continue
    elif not cores:
        print('Error: unknown configuration token before the first [core] on line %d.' % n)
        errors = True
        continue
    l = [x.strip() for x in l.split('=', 1)]
    if len(l) != 2:
        print('Error: syntax error on line %d.' % n)
        errors = True
        continue
    if l[0] not in keys:
        print('Error: unknown configuration key on line %d.' % n)
        errors = True
        continue
    cores[-1][l[0]] = (n, l[1])
for c in cores:
    for k in keys:
        if k not in c:
            print('Error: core defined on line %d is missing configuration key %s.' % (c['linenr'], k))
            errors = True
    linenr = c['linenr']
    del c['linenr']
    nc = {}
    for k in c:
        n, v = c[k]
        if k.endswith('CACHE'):
            mult = 1
            if v.endswith('k'):
                mult = 1024
                v = v[:-1].strip()
            try:
                v = int(v) * mult
            except ValueError:
                print('Error: parse error on line %d.' % n)
                errors = True
                continue
            if (v & (v - 1)) != 0:
                print('Error: cache size is not a power of 2 on line %d.' % n)
                errors = True
                continue
            v = int.bit_length(v) - 1
            nc[k[0].lower() + 'cacheLog2'] = v
        elif k == 'CONFIG':
            v = v[::-1]
            vc = v.replace(':', '')
            v = v.split(':')
            
            # Check multiplier config.
            try:
                nv = int(vc, 16)
                if nv & 0xEEEEEEEE:
                    raise ValueError()
            except ValueError:
                print('Error: parse error on line %d.' % n)
                errors = True
                continue
            if nv == 0:
                print('Error: there should be at least one multiplier in the core on line %d.' % n)
                errors = True
                continue
            
            # Check issue width.
            if len(vc) not in [2, 4, 8]:
                print('Error: issue width must be 2, 4, or 8 on line %d.' % n)
                errors = True
                continue
            
            # Check reconfiguration config.
            if len(v) not in [1, 2, 4]:
                print('Error: all groups must have the same issue width on line %d.' % n)
                errors = True
                continue
            if len(v[0]) not in [2, 4, 8]:
                print('Error: the issue width of a group must be 2, 4, or 8 on line %d.' % n)
                errors = True
                break
            if '1' not in v[0]:
                print('Error: each group should have at least one multiplier on line %d.' % n)
                errors = True
                break
            for vg in v:
                if vg != v[0]:
                    print('Error: all groups must have the same issue width and multiplier config on line %d.' % n)
                    errors = True
                    break
            
            # Configure the hardware.
            nc['numLanes'] = len(vc)
            nc['numLanesLog2'] = [1, 2, 4, 8].index(len(vc))
            nc['numLanesPerGroup'] = len(v[0])
            nc['numLaneGroups'] = len(v)
            nc['numLaneGroupsLog2'] = [1, 2, 4].index(len(v))
            nc['numContexts'] = len(v)
            nc['numContextsLog2'] = [1, 2, 4].index(len(v))
            nc['memLaneRevIndex'] = len(v[0]) - 1
            nc['multipliers'] = vc
            
            # Configure the compiler.
            if len(v) > 1:
                nc['compiler-genbin'] = True
                nc['compiler-width'] = 8
                nc['compiler-config'] = v[0] * (8 // len(v[0]))
            else:
                nc['compiler-genbin'] = False
                nc['compiler-width'] = len(vc)
                nc['compiler-config'] = vc
            nc['compiler-multCount'] = nc['compiler-config'].count('1')

        elif k == 'STOPBIT':
            if v not in ['2', '4', '8']:
                print('Error: stop bit config must be 2, 4, or 8 on line %d.' % n)
                errors = True
                continue
            nc['bundleAlignLog2'] = int.bit_length(int(v)) - 1
            nc['compiler-bundleAlign'] = int(v)
            
        else:
            raise RuntimeError('No parser for key %s', k)
    if 'icacheLog2' in nc and 'numLanesLog2' in nc:
        nc['icacheLog2'] -= nc['numLaneGroupsLog2'] + nc['numLanesLog2'] + 2
        if nc['icacheLog2'] < 1:
            print('Error: instruction cache too small on line %d.' % c['ICACHE'][0])
            errors = True
            continue
    if 'dcacheLog2' in nc:
        nc['dcacheLog2'] -= nc['numLaneGroupsLog2'] + 2
        if nc['dcacheLog2'] < 1:
            print('Error: data cache too small on line %d.' % c['DCACHE'][0])
            errors = True
            continue
    if 'bundleAlignLog2' in nc and 'numLanesLog2' in nc:
        if nc['bundleAlignLog2'] > nc['numLanesLog2']:
            nc['bundleAlignLog2'] = nc['numLanesLog2']
            nc['compiler-bundleAlign'] = 2**nc['numLanesLog2']
            print('Warning: stop bit config is greater than issue width for core on line %d.' % linenr)
    if 'bundleAlignLog2' in nc and 'numLanesLog2' in nc and 'compiler-width' in nc:
        limmprev = nc['bundleAlignLog2'] >= nc['numLanesLog2']
        if nc['compiler-width'] == 2:
            limmprev = False # No need for limmh-prev logic in a 2-way core.
        nc['limmhFromPreviousPair'] = limmprev
        if limmprev:
            nc['compiler-borrow'] = {4: '1.0.3,0.2,1', 8: '1.0.3,0.2,1.5,2.4,3.7,4.6,5'}[nc['compiler-width']]
        else:
            nc['compiler-borrow'] = {2: '1.0', 4: '1.0.3.2', 8: '1.0.3.2.5.4.7.6'}[nc['compiler-width']]
    if 'numContextsLog2' in nc:
        resets = []
        logs = []
        for i in range(nc['numContexts']):
            if mem_start + mem_length >= mem_end:
                print('Error: too many cores/contexts; out of memory.')
                errors = True
            if log_start + log_length >= log_end:
                print('Error: too many cores/contexts; out of memory.')
                errors = True
            resets.append(mem_start)
            logs.append(log_start)
            mem_start += mem_length
            log_start += log_length
        nc['resetVectors'] = resets
        nc['memSize'] = mem_length
        nc['logRegions'] = logs
        nc['logSize'] = log_length
    
    if not errors:
        # Figure out the lane configuration for the compiler:
        #  - Bit 0: ALU
        laneconfig = int('1' * nc['compiler-width'], 16)
        #  - Bit 1: Multiplier
        laneconfig |= int(nc['compiler-config'], 16) << 1
        #  - Bit 2: Memory
        mem = ['0'] * nc['numLanesPerGroup']
        mem[-(nc['memLaneRevIndex'] + 1)] = '4'
        mem = ''.join(mem)
        mem *= nc['compiler-width'] // nc['numLanesPerGroup']
        laneconfig |= int(mem, 16)
        #  - Bit 3: Branch
        br = ['0'] * nc['compiler-width']
        for i in range(0, nc['compiler-width'], nc['compiler-bundleAlign']):
            br[i + nc['compiler-bundleAlign'] - 1] = '8'
        laneconfig |= int(''.join(br), 16)
        # And store it as a string.
        nc['compiler-config'] = '%0*X' % (nc['compiler-width'], laneconfig)
    
    c.clear()
    c.update(nc)
if errors:
    sys.exit(1)

# Determine which benchmarks this group needs to run.
benchmarks_file = '/home/user/workspace/assignment2/benchmarks'
if not os.path.isfile(benchmarks_file):
    print('Warning: benchmarks file does not exist. Cannot properly initialize src directory.')
    print('  (/home/user/workspace/assignment2/benchmarks)')
    benchmarks = []
else:
    with open(benchmarks_file, 'r') as f:
        benchmarks = [x.strip() for x in f.readlines()[2:]]


###############################################################################
# Ask for overwriting existing directories. There should not be any errors    #
# due to user config after this point.                                        #
###############################################################################

# Query overriding data and results.
if os.path.isdir('data') or os.path.isdir('results'):
    print('Warning! Reconfiguring will delete all files in the data and results directories!')
    print('That includes any synthesis data/bitstreams that you may have built here. Are')
    print('you sure you want to delete these things? [y/n]')
    if input() != 'y':
        sys.exit(0)

# Query overriding the source directory.
if os.path.isdir('src'):
    print('It looks like you already have a src directory. Would you like to keep your')
    print('current sources to edit them manually, or would you like to generate new source')
    print('files?')
    print('  Option 1: keep current files.')
    print('  Option 2: generate new files (current sources are permanently deleted).')
    print('  Option 3: cancel operation.')
    print('Enter 1, 2 or 3.')
    v = input()
    if v == '2':
        rm('-rf', 'src')
    elif v != '1':
        sys.exit(0)

# Remove the current data/results directories.
rm('-rf', 'data')
rm('-rf', 'results')
mkdir('-p', 'results')
rm('-f', 'Makefile')


###############################################################################
# Generate the src directory.                                                 #
###############################################################################

# If the source directory does not exist yet, construct it.
if not os.path.isdir('src'):
    mkdir('-p', 'src')
    
    # Copy the benchmark sources into the src tree.
    benchmarks_old = benchmarks
    benchmarks = []
    for b in benchmarks_old:
        filename = '/home/user/workspace/assignment2/powerstone/%s.c' % b
        if not os.path.isfile(filename):
            print('Warning: cannot find source for benchmark "%s". Removing benchmark from list.', b)
            print('  (%s)', filename)
        else:
            cp('-p', filename, 'src')
            benchmarks.append(b)
    
    # Generate the benchmark entry point header file.
    fname = 'src/benchmarks.h'
    contents = []
    contents.append('')
    contents.append('#ifndef _BENCHMARKS_H_')
    contents.append('#define _BENCHMARKS_H_')
    contents.append('')
    if not benchmarks:
        contents.append('// Benchmark entry points have the prototype int main_<name>(void).')
        contents.append('// Add the declarations for your benchmarks here.')
        contents.append('')
    else:
        for b in benchmarks:
            contents.append('// Runs the %s benchmark.' % b)
            contents.append('int main_%s(void);' % b)
            contents.append('')
    first_core = False
    contents.append('#endif')
    contents.append('')
    with open(fname, 'w') as f:
        f.write('\n'.join(contents))
    
    # Generate the entry point C file for each core.
    first_core = True
    for ci, c in enumerate(cores):
        for i in range(c['numContexts']):
            if c['numContexts'] > 1:
                fname = 'src/main-core%d-ctxt%d.c' % (ci, i)
            else:
                fname = 'src/main-core%d.c' % ci
            contents = []
            contents.append('')
            contents.append('// Declarations for the benchmark main() functions.')
            contents.append('#include "benchmarks.h"')
            contents.append('')
            contents.append('// Debug output functions (puts, etc.; NO printf).')
            contents.append('#include <record.h>')
            contents.append('')
            contents.append('// Core control register definitions.')
            contents.append('#include <rvex.h>')
            contents.append('')
            contents.append('// This variable is used by the debug message recorder. It must be initialized')
            contents.append('// to 0x1F000000 + global_context_index * 0x100000.')
            contents.append('volatile char *record_ptr = (volatile char *)0x%08X;' % c['logRegions'][i])
            contents.append('')
            contents.append('int main(void) {')
            contents.append('    ')
            if i != 0:
                contents.append('    // NOTE: after reset, this context is not assigned any computational')
                contents.append('    // resources. So any code here will not run automatically! To use this')
                contents.append('    // context, you need to give a reconfiguration command in context 0 of')
                contents.append('    // this core. Refer to r-VEX.pdf.')
                contents.append('    ')
            if first_core:
                if not benchmarks:
                    contents.append('    // Insert your code here.')
                    contents.append('    ')
                else:
                    contents.append('    // Log the performance counters for debugging purposes. This times the C')
                    contents.append('    // runtime initialization code. Note that the logging takes time as well;')
                    contents.append('    // you might want to remove them for your final measurements. The server')
                    contents.append('    // and simulation will always give you a total cycle count.')
                    contents.append('    log_perfcount("init");')
                    contents.append('    ')
                    for b in benchmarks:
                        contents.append('    // Run the %s benchmark and log performance.' % b)
                        contents.append('    %s_main();' % b)
                        contents.append('    log_perfcount("%s");' % b)
                        contents.append('    ')
                first_core = False
            else:
                contents.append('    // This context/core currently does not do anything. You should insert your own')
                contents.append('    // code here by moving benchmarks from core 0/context 0.')
                contents.append('    ')
            contents.append('}')
            contents.append('')
            with open(fname, 'w') as f:
                f.write('\n'.join(contents))

    # Generate the compilation configuration file.
    fname = 'src/config.compile'
    contents = []
    contents.append('')
    contents.append('# This file specifies which non-library sources to compile for which')
    contents.append('# core/context, and using which compiler flags.')
    contents.append('')
    first_core = True
    for ci, c in enumerate(cores):
        for i in range(c['numContexts']):
            contents.append('#'+'-'*78)
            s = '[core%d.%d]' % (ci, i)
            if c['numContexts'] > 1:
                s += ' # Configuration for core %d, hardware context %d.' % (ci, i)
            else:
                s += ' # Configuration for core %d.' % ci
            contents.append(s)
            contents.append('#'+'-'*78)
            contents.append('')
            contents.append('# Compile the entry point file.')
            if c['numContexts'] > 1:
                contents.append('%-25s -O3' % ('main-core%d-ctxt%d' % (ci, i)))
            else:
                contents.append('%-25s -O3' % ('main-core%d' % ci))
            contents.append('')
            if first_core:
                if benchmarks:
                    contents.append('# Compile the benchmarks. The -sub parts tell the compiler to add the')
                    contents.append('# benchmark name as a prefix to all global functions andvariables, in order')
                    contents.append('# to make them unique. For instance, the int main(void) function in the')
                    contents.append('# %s.c file can be called using main_%s().' % (benchmarks[0], benchmarks[0]))
                    for b in benchmarks:
                        contents.append('%-25s -O3' % ('%s-sub' % b))
                    contents.append('')
                first_core = False
            contents.append('# Compile the library sources (floating point functions, debugging, etc.) with')
            contents.append('# -O3 to optimize them.')
            contents.append('%-25s -O3' % 'OTHERS')
            contents.append('')
    contents.append('')
    with open(fname, 'w') as f:
        f.write('\n'.join(contents))


###############################################################################
# Generate the data/compile directory.                                        #
###############################################################################

# Create the directories.
for ci, c in enumerate(cores):
    for i in range(c['numContexts']):
        mkdir('-p', 'data/compile/core%d.%d' % (ci, i))

# Link the output file merging makefile.
ln('/home/user/workspace/tools/scripts/compile-merge.makefile', 'data/compile/Makefile')

# Create the per-core makefiles.
for ci, c in enumerate(cores):
    for i in range(c['numContexts']):
        fname = 'data/compile/core%d.%d/Makefile' % (ci, i)
        contents = []
        contents.append('')
        contents.append('CONTEXT_ID     = core%d.%d' % (ci, i))
        contents.append('GENERIC_BINARY = %s' % ('true' if c['compiler-genbin'] else 'false'))
        contents.append('ISSUE_WIDTH    = %s' % c['compiler-width'])
        contents.append('BORROW         = %s' % c['compiler-borrow'])
        contents.append('LANECONFIG     = %s' % c['compiler-config'])
        contents.append('BUNDLE_ALIGN   = %s' % c['compiler-bundleAlign'])
        contents.append('')
        contents.append('include /home/user/workspace/tools/scripts/compile.makefile')
        contents.append('')
        with open(fname, 'w') as f:
            f.write('\n'.join(contents))

# Create the machine configurations.
for ci, c in enumerate(cores):
    for i in range(c['numContexts']):
        fname = 'data/compile/core%d.%d/config.mm' % (ci, i)
        contents = []
        contents.append('')
        contents.append('RES: IssueWidth     %d' % c['compiler-width'])
        contents.append('RES: MemLoad        1')
        contents.append('RES: MemStore       1')
        contents.append('RES: MemPft         0')
        contents.append('# ***Clusters***    1')
        contents.append('RES: IssueWidth.0   %d' % c['compiler-width'])
        contents.append('RES: Alu.0          %d' % c['compiler-width'])
        contents.append('RES: Mpy.0          %d' % c['compiler-multCount'])
        contents.append('RES: Memory.0       1')
        contents.append('RES: CopySrc.0      1')
        contents.append('RES: CopyDst.0      1')
        contents.append('REG: $r0            63')
        contents.append('REG: $b0            8')
        contents.append('DEL: AluR.0         0')
        contents.append('DEL: Alu.0          0')
        contents.append('DEL: CmpBr.0        0')
        contents.append('DEL: CmpGr.0        0')
        contents.append('DEL: Select.0       0')
        contents.append('DEL: Multiply.0     1')
        contents.append('DEL: Load.0         1')
        contents.append('DEL: LoadLr.0       1')
        contents.append('DEL: Store.0        0')
        contents.append('DEL: Pft.0          0')
        contents.append('DEL: CpGrBr.0       0')
        contents.append('DEL: CpBrGr.0       0')
        contents.append('DEL: CpGrLr.0       0')
        contents.append('DEL: CpLrGr.0       0')
        contents.append('DEL: Spill.0        0')
        contents.append('DEL: Restore.0      1')
        contents.append('DEL: RestoreLr.0    1')
        contents.append('CFG: Quit           0')
        contents.append('CFG: Warn           0')
        contents.append('CFG: Debug          0')
        contents.append('')
        with open(fname, 'w') as f:
            f.write('\n'.join(contents))

# Create the linker scripts.
for ci, c in enumerate(cores):
    for i in range(c['numContexts']):
        fname = 'data/compile/core%d.%d/config.x' % (ci, i)
        contents = []
        contents.append('')
        contents.append('OUTPUT_FORMAT("elf32-rvex")')
        contents.append('OUTPUT_ARCH(rvex)')
        contents.append('ENTRY(_start)')
        contents.append('MEMORY')
        contents.append('{')
        contents.append('  ram : ORIGIN = 0x%08X, LENGTH = %dM' % (c['resetVectors'][i], c['memSize'] >> 20))
        contents.append('}')
        contents.append('SECTIONS')
        contents.append('{')
        contents.append('  .text :')
        contents.append('  {')
        contents.append('    __TEXT_START = .;')
        contents.append('    *(.init)')
        contents.append('    *(.text)')
        contents.append('    __TEXT_END = .;')
        contents.append('  } > ram')
        contents.append('  .data :')
        contents.append('  {')
        contents.append('    __DATA_START = .;')
        contents.append('    *(.rodata*)')
        contents.append('    *(.data_4) *(.data_2) *(.data_1) *(.data) *(.data.*) *(.gnu.linkonce.d.*)')
        contents.append('    __DATA_END = .;')
        contents.append('    . = ALIGN(16);')
        contents.append('  } > ram')
        contents.append('  .bss (NOLOAD) :')
        contents.append('  {')
        contents.append('    __BSS_START = .;')
        contents.append('    *(.bss_4) *(.bss_2) *(.bss_1) *(.bss) *(COMMON) *(.bss.*) *(.gnu.linkonce.b.*)')
        contents.append('    __BSS_END = .;')
        contents.append('  } > ram')
        contents.append('  .stack (NOLOAD) :')
        contents.append('  {')
        contents.append('    . = ALIGN(4);')
        contents.append('    . += 0x6000;')
        contents.append('    __STACK_START = .;')
        contents.append('  } > ram')
        contents.append('  .heap (NOLOAD) :')
        contents.append('  {')
        contents.append('    . = ALIGN(4);')
        contents.append('    end = .;')
        contents.append('    _end = .;')
        contents.append('    __HEAP_START = .;')
        contents.append('    . += 0x200000; ')
        contents.append('    __HEAP_MAX = .;')
        contents.append('  } > ram')
        contents.append('  .comment        0 : { *(.comment) }')
        contents.append('  .debug_aranges  0 : { *(.debug_aranges) }')
        contents.append('  .debug_pubnames 0 : { *(.debug_pubnames) }')
        contents.append('  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }')
        contents.append('  .debug_abbrev   0 : { *(.debug_abbrev) }')
        contents.append('  .debug_line     0 : { *(.debug_line) }')
        contents.append('  .debug_frame    0 : { *(.debug_frame) }')
        contents.append('  .debug_str      0 : { *(.debug_str) }')
        contents.append('  .debug_loc      0 : { *(.debug_loc) }')
        contents.append('  .debug_macinfo  0 : { *(.debug_macinfo) }')
        contents.append('}')
        contents.append('__DATA_IMAGE_START = LOADADDR(.data);')
        contents.append('')
        with open(fname, 'w') as f:
            f.write('\n'.join(contents))


###############################################################################
# Generate the data/fpga directory.                                           #
###############################################################################

# Create the directory.
mkdir('-p', 'data/fpga')

# Link the FPGA makefile.
ln('/home/user/workspace/tools/scripts/fpga.makefile', 'data/fpga/Makefile')

# Generate the grlib config.vhd file.
fname = 'data/fpga/config.vhd'
contents = []
contents.append('')
contents.append('library techmap;')
contents.append('use techmap.gencomp.all;')
contents.append('')
contents.append('library ieee;')
contents.append('use ieee.std_logic_1164.all;')
contents.append('')
contents.append('library rvex;')
contents.append('use rvex.common_pkg.all;')
contents.append('use rvex.core_pkg.all;')
contents.append('use rvex.cache_pkg.all;')
contents.append('use rvex.rvsys_grlib_pkg.all;')
contents.append('')
contents.append('package config is')
contents.append('  -- Technology and synthesis options.')
contents.append('  constant CFG_FABTECH : integer := virtex6;')
contents.append('  constant CFG_MEMTECH : integer := virtex6;')
contents.append('  constant CFG_PADTECH : integer := virtex6;')
contents.append('  constant CFG_NOASYNC : integer := 0;')
contents.append('  constant CFG_SCAN : integer := 0;')
contents.append('  ')
contents.append('  -- r-VEX processor core configuration.')
contents.append('  constant CFG_NRVEX : integer := %d;' % len(cores))
contents.append('  constant CFG_RVEX_CFG : rvex_grlib_generic_config_array(0 to CFG_NRVEX-1) := (')
contents.append('    ')
for ci, c in enumerate(cores):
    contents.append('    -- Core %d configuration.' % ci)
    contents.append('    %d => rvex_grlib_cfg(' % ci)
    contents.append('      core => rvex_cfg(')
    contents.append('        numLanesLog2          => %d,' % c['numLanesLog2'])
    contents.append('        numLaneGroupsLog2     => %d,' % c['numLaneGroupsLog2'])
    contents.append('        numContextsLog2       => %d,' % c['numContextsLog2'])
    contents.append('        bundleAlignLog2       => %d,' % c['bundleAlignLog2'])
    contents.append('        multiplierLanes       => 2#%s#,' % c['multipliers'])
    contents.append('        memLaneRevIndex       => %d,' % c['memLaneRevIndex'])
    contents.append('        numBreakpoints        => 0,')
    contents.append('        forwarding            => 1,')
    contents.append('        limmhFromPreviousPair => %d,' % (1 if c['limmhFromPreviousPair'] else 0))
    contents.append('        resetVectors          => (')
    for i in range(c['numContexts']):
        contents.append('          %d => X"%08X",' % (i, c['resetVectors'][i]))
    contents.append('          others => X"00000000"')
    contents.append('        ),')
    contents.append('        traceEnable           => 0,')
    contents.append('        perfCountSize         => 4,')
    contents.append('        cachePerfCountEnable  => 1')
    contents.append('      ),')
    contents.append('      core_valid => true,')
    contents.append('      cache => cache_cfg(')
    contents.append('        instrCacheLinesLog2   => %d,' % c['icacheLog2'])
    contents.append('        dataCacheLinesLog2    => %d'  % c['dcacheLog2'])
    contents.append('      ),')
    contents.append('      cache_valid => true')
    if ci == len(cores) - 1:
        contents.append('    )')
    else:
        contents.append('    ),')
    contents.append('    ')
contents.append('  );')
contents.append('  ')
contents.append('  -- Total number of processors.')
contents.append('  constant CFG_NLG : integer := rvex_grlib_num_lane_groups(CFG_RVEX_CFG);')
contents.append('  constant CFG_NCTXT : integer := rvex_grlib_num_contexts(CFG_RVEX_CFG);')
contents.append('  ')
contents.append('  -- AMBA settings.')
contents.append('  constant CFG_FPNPEN : integer := 0;')
contents.append('  constant CFG_AHBIO : integer := 16#FFF#;')
contents.append('  constant CFG_APBADDR : integer := 16#800#;')
contents.append('  constant CFG_AHB_MON : integer := 0;')
contents.append('  constant CFG_AHB_MONERR : integer := 0;')
contents.append('  constant CFG_AHB_MONWAR : integer := 0;')
contents.append('  constant CFG_AHB_DTRACE : integer := 0;')
contents.append('  ')
contents.append('  -- Xilinx MIG DDR2 controller.')
contents.append('  constant CFG_MIG_DDR2 : integer := 1;')
contents.append('  --constant CFG_MIG_CLK4 : integer := 30; -- 40 MHz     (5.0ns sync with 200MHz DDR)')
contents.append('  --constant CFG_MIG_CLK4 : integer := 32; -- 37.5 MHz   (1.6ns sync with 200MHz DDR)')
contents.append('  --constant CFG_MIG_CLK4 : integer := 33; -- 36.36 MHz  (2.5ns sync with 200MHz DDR)')
contents.append('  --constant CFG_MIG_CLK4 : integer := 36; -- 33.33 MHz  (5.0ns sync with 200MHz DDR)')
contents.append('  --constant CFG_MIG_CLK4 : integer := 40; -- 30 MHz     (1.6ns sync with 200MHz DDR)')
contents.append('    constant CFG_MIG_CLK4 : integer := 60; -- 20 MHz     (5.0ns sync with 200MHz DDR)')
contents.append('  ')
contents.append('end;')
contents.append('')
with open(fname, 'w') as f:
    f.write('\n'.join(contents))

# Generate the modelsim .do script.
fname = 'data/fpga/phy.do'
contents = []
contents.append('')
for ci in range(len(cores)):
    contents.append('add wave -label "Core %d" -expand sim:/testbench/d3/rvsys_gen(%d)/rvsys_inst/rvex_block/rvex_inst/rv2sim' % (ci, ci))
contents.append('')
with open(fname, 'w') as f:
    f.write('\n'.join(contents))


###############################################################################
# Link the toplevel makefile.                                                 #
###############################################################################

# Link the toplevel makefile.
ln('/home/user/workspace/tools/scripts/assignment2.makefile', 'Makefile')
